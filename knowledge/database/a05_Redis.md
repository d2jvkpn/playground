### Database: Redis
---

**Links**
- https://redis.io/docs/data-types

#### 1. Redis 数据类型与应用
- String: SET, GET, APPEND
- List: LINDEX, LLEN, LINSERT
- Hash: HSET, HGET, HDEL
- Set: SADD, SCARD, SDIFF, SISMEMBER, SREM
- Sorted Set: ZADD, ZDIFF, ZCOUNT, ZRANGE
- Bitmap: BITOP, BITCOUNT, BITPOS
- Hyperloglog: PFADD, PFCOUNT, PFMERGE
- JSON: JSON.GET, JSON.SET, JSON.DEL
- Index: FT.SEARCH, FT.CREATE, FT.PROFILE

#### 2. Features
- All data is stored in memory
- Data is organised in simple data structures
- Redis has a simple feature set

#### 3. Redis 内存击穿、穿透、雪崩
@ChatGPT
缓存击穿、缓存穿透、缓存雪崩是缓存系统中常见的问题。

1. 缓存击穿：缓存击穿是指一个存在的key，高并发直接请求这个key，当这个key在过期的瞬间，可能会导致大量的请求直接到数据库，从而可能会导致数据库瞬间压力过大。一般解决方案是，对于查询并更新频率高的key，可以选择使用互斥锁或者读写锁来保证在key过期的瞬间只有一个线程去数据库查询数据和更新缓存。

2. 缓存穿透：缓存穿透是指查询一个不存在的数据，由于缓存中也不存在，所以会导致所有的请求都直接到数据库，对数据库产生压力。解决方案就是永不过期，即对查询的数据，即使是不存在的数据，也进行缓存。可以设置一个默认值或者空值存放，过一段时间后过期即可。

3. 缓存雪崩：当缓存服务器重启或者大量的key同时过期，可能会造成瞬间大量的请求直接到数据库，这就叫做缓存雪崩。一般解决方案是对key的过期时间添加一些随机值，避免所有的key同时过期；还有就是对热点key设置永不过期；另外就是制定服务降级方案，比如先返回旧数据或者返回自定义错误等。

#### 4. Redis 大 Key 问题
@ChatGPT
Redis的"大Key"问题是指Redis中的某个键所对应的值的数据量过大，比如一个字节很长的字符串、元素数量很多的哈希表、列表、集合或有序集合等。这些大Key在读写、删除、过期等操作中，会造成Redis阻塞，从而影响Redis的服务质量。

这种情况主要是由于Redis的单线程模型导致的，Redis在进行任何数据操作时都是串行的，也就是一次只能处理一条指令，因此处理大Key会消耗大量时间，进而造成阻塞问题。其解决方案主要包括以下几种：

1. 定期检查和清理大Key，尤其是那些没有设置过期时间或者过期时间过长的Key。
2. 避免在设计应用时使用大Key，如有需要，可以对大Key进行分片处理，将大块数据拆分到多个小key中。
3. 对于大型数据操作，可以采用hscan、sscan、zscan等指令替代全量操作，逐步读取数据，避免阻塞。
4. 优化代码，避免一次性对大Key进行大量操作，减小对Redis的压力。
5. 对于频繁读写的大Key，可以考虑使用其他存储服务，如MySQL等，避免过度依赖Redis

#### 5. Redis 缓存淘汰机制
@ChatGPT
Redis 缓存淘汰机制是一种用于管理 Redis 缓存的策略，当 Redis 内存数据达到上限，需要继续向内存添加数据时，此时就需要按照某种策略来淘汰部分已存在的数据，以便释放内存。

Redis 提供了多种淘汰策略，如下：
1. noeviction：当内存使用达到阈值时，对新的写入请求会报错。
2. allkeys-lru：从数据集（server.db[i].dict）中挑选出最近最少使用（LRU）的数据淘汰。
3. volatile-lru：从设置了过期时间的数据集（server.db[i].expires）中挑选出最近最少使用（LRU）的数据淘汰。
4. allkeys-random：从数据集中任意选择数据淘汰。
5. volatile-random：从设置了过期时间的数据集中任意选择数据淘汰。
6. volatile-ttl：优先对即将过期的数据进行淘汰。

具体选用哪种淘汰策略，取决于使用Redis的具体业务需求。各种淘汰策略的主要区别在于策略采取的是淘汰近期最少使用的、具有超时时间的、随机的键，还是不淘汰。

#### 6. Q & A
1. 问题: Redis是什么？
  答: Redis是一个开源的，使用ANSI C编写，支持网络、可基于内存亦可持久化的日志型、Key-Value数据库（存储）并提供多种语言的API，也被用作缓存和消息队列使用。

2. 问题: Redis支持哪些操作数据类型的命令？
  答: Redis各类数据类型支持的命令如下：
  - String（字符串）数据类型的常用命令: GET、SET、INCR、DECR、APPEND。
  - Hash（哈希）数据类型的常用命令：HMGET、HMSET、HGETALL。
  - List（列表）数据类型的常用命令：LPUSH、LPOP、RPUSH、RPOP、LINDEX、LRANGE、LREM。
  - Set（集合）数据类型的常用命令：SADD、SPOP、SREM、SISMEMBER、SMEMBERS。
  - Sorted Set（有序集合）数据类型的常用命令：ZADD、ZSCORE、ZRANGE、ZREVRANGE、ZRANK、ZREVRANK。

3. 问题: 为什么Redis单线程模型也能做到高性能？
  答: Redis是基于内存操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器的内存大小或者网络带宽。单线程避免了线程切换和竞态消耗的时间。

4. 问题: Redis的单线程模型有什么优缺点？
**优点**:
- 简化性。在编程模型、数据的一致性等方面，单线程应用程序比多线程应用程序更简单。也就是说你不需要考虑多线程编程的同步问题，就可以轻易地编写出无bug的代码。
- 低延迟。由于Redis运行在单线程环境中，操作请求之间不存在上下文切换的开销，而且所有操作都是原子性的，因此延迟极低。
- 高性能。单线程应用程序可以避免多线程环境中发生的各种锁冲突，并可以完全利用CPU的预处理能力。
**缺点**：
- 无法充分利用多核CPU。在多核CPU架构的年代，一台机器可能有多个CPU核心，而Redis的单线程模型无法同时充分利用这些核心，也就不能充分发挥硬件的性能。
- 处理大量网络I/O时效率低。当大量的客户端同时发起网络请求，由于Redis只有单线程在处理，如果是阻塞I/O，可能导致效率低下。
- 可扩展性差。由于Redis是单线程模型，要想达到更高的处理能力，一般只能通过增加实例数进行水平扩展，不能通过增加硬件的计算能力进行垂直扩展。
- 阻塞性任务可能导致整体性能下降。因为Redis所有的操作都是在一个线程里串行执行的，所以只要有一个任务阻塞了，那么后续的所有任务都会受到影响，这可能导致整体的性能下降。例如，在数据的持久化操作中，如果硬盘的I/O不够快，可能就会拖慢整个系统的效率

5. 问题: 使用Redis有哪些好处?
  答：
- 高性能：Redis能读的速度是110000次/s，写的速度是81000次/s。
- 支持丰富的数据类型：Redis支持最基本的字符串，同时还提供list，set，zset，hash等数据结构的存储。
- 数据持久化：可以定期保存数据至硬盘中或将每次的修改都立即保存。这样可以保护数据，防止数据丢失。
- 支持事务：所有的redis操作都是原子性的，同时redis还支持对几个操作合并后的原子性执行。
- 提供发布订阅机制：客户端可以订阅任意数量的频道，当有消息发布到这些频道时，这些订阅了这个频道的客户端会收到相关消息。
- 支持主从复制：可以将数据复制到任意数量的从服务器中，解决了读取性能问题，同时对于数据的备份也有着重要作用。
- 占用内存少：Redis使用C语言编写，经过多次优化后，其内存管理效率非常高。
- 高并发处理能力强：由于是基于内存操作，Redis读写速度非常快，能处理高并发读写。
- 使用方便：安装和使用都非常方便，可以直接在官网下载安装，使用也有详细的官方文档支持

6. 问题: 什么是Redis的持久化？Redis实现持久化的方式有哪些？
  答: Redis的持久化是指将内存中的数据写入磁盘，以防止丢失。 持久化的方式主要有RDB和AOF，RDB是快照形式的持久化，AOF是日志形式的持久化。

7. 问题: 请解释Redis如何进行事务处理？
  答: Redis的事务类似于其他数据库的绝对意义的事务，它是一种将多个命令请求包装到一起，然后一次性、按顺序地执行完成。如果在这个集合的命令中出现错误或者失败，那么后续的命令仍然会被执行下去。

8. 问题: 怎样理解Redis的发布订阅功能？
  答: Redis的发布订阅(pub/sub)是一种消息通信模式，发送者(pub)发送消息，订阅者(sub)接受消息，Redis作为一个存储和传输层，订阅者可以订阅一次或者多次，这是一个非常实用的特性，可以用来构建即时消息系统，或者用来构建任务队列系统等等。

9. 问题: 如何理解Redis的pipeline方式？
  答: Pipeline方式是由于Redis的网络数据都是通过队列的形式进行存储，然后数据从一个队列进入，数据存储之后再将数据返回给客户端。当我们在处理大量数据时，往往需要多次操作，使用pipeline可以在一定程度上。

10. 问题: Redis如何实现分布式事务？
  答: Redis本身并不直接支持分布式事务，但是我们可以通过一些机制和策略模拟实现分布式事务。我们可以使用Redis的以下三种特性来实现分布式事务：
- 1. MULTI/EXEC 命令：Redis的 MULTI 和 EXEC 命令提供了事务的一致性，它可以保证在 MULTI 和 EXEC 之间的命令序列作为一个原子单元执行，要么全部执行，要么全部不执行。
- WATCH 命令：Redis提供了 WATCH 命令来支持乐观锁，当我们需要更新的数据在事务运行期间被其他客户端改变，事务将会失败。WATCH命令会监测我们在 EXEC 命令之前定义的一组关键字，如果这些关键字在 EXEC 命令执行前被其他客户端修改，那么事务就会被取消并返回一个错误。
- 分布式锁：我们可以自行实现分布式锁，当需要对一些数据进行原子性的更新时，我们可以先获取分布式锁，然后再进行操作。
- Lua脚本：Redis从2.6版本开始增加了对于Lua脚本的支持，Lua脚本在Redis中的执行是原子的，我们可以借助Lua脚本来实现复杂的事务逻辑。

需要注意的是，即使通过上述方式，Redis也只能保证在单个redis实例上的命令原子性的执行，但是在分布式环境下，无法保证多个Redis实例之间的命令一致性。所以，要实现分布式事务仍需要搭配其他技术或方案。

11. 问题: 描述如何使用Redis进行分布式锁。
  答: 分布式锁是一种在分布式系统中控制并发访问共享资源的机制。在多个运行节点的环境中，只有拥有该锁的进程或线程能够访问受保护的代码部分。在Redis中，可以通过以下步骤实现分布式锁：
- 设置锁：客户端执行SETNX命令，在键不存在的情况下设值。这个操作应该将锁的名字，以及一个唯一的标识作为值，这个唯一标识在解锁时会用到。如果值设置成功，表示获取到了锁，执行相关代码。
- 控制超时：为了防止因为某种原因导致拥有锁的客户端没有主动释放锁，我们在上一步的基础上加上一个超时时间。在Redis中，我们可以通过SETNX命令后，再执行一个EXPIRE命令来为key设定超时时间。
- 释放锁：当业务逻辑执行完成，无论是否成功或者失败，都应该执行删除键值对的操作来释放锁。这个删除操作需要能够保证只有获得锁的客户端才能删除。可以通过比对键对应的值来校验客户端的身份，只有值匹配的客户端才能删除锁。

为了让设置锁和超时命令成为一个原子操作，可以使用Lua脚本或Redis的MULTI/EXEC命令组合。同理，解锁操作也需要设计为原子操作。
最后，需要注意的是，由于网络延迟等原因可能会造成多个客户端都误认为自己获得了锁，所以在设计分布式锁时必须要慎重。

12. 问题: 怎么去保证Redis的高可用性？
13. 如何解决Redis的内存溢出问题？
14. Redis在什么情况下可能会遇到性能问题？你有什么解决方法？
15. 你通常如何优化Redis的性能？
16. 在哪些情况下，你会选择Redis作为数据存储？
17. 什么是Redis的集群模式？与主从复制有何区别？
18. 怎么理解Redis的数据一致性问题？它的解决方式是什么？
19. 请介绍一下Redis sentinel, 它有什么作用？
